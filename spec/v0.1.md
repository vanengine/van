# Van Spec v0.1

> **Status**: Draft
> **Date**: 2026-02-08

---

## 1. Overview

**Van** is a **language-agnostic template rendering engine** that uses Vue SFC syntax. It compiles `.van` templates into server-rendered HTML for any backend.

- **Van** — the template engine (core). Parses `.van` → compiles → renders HTML. Language-agnostic.
- **`ym`** — the CLI build tool for Van (like yarn/vite). Orchestrates Van compilation (server + client), manages UI packages.
- **File format**: `.van` (Vue SFC syntax with Van extensions, IDE support via `van-language-server`)
- **Core value**: Vue DX + backend rendering — write templates with frontend developer experience, render on any server. Client-side JS is compiled by Van's Signal Compiler into minimal signal-based JS (no virtual DOM, ~4KB runtime).

### 1.1 Van vs `ym`

| | **Van** | **`ym` (Yummy)** |
|---|---|---|
| What | Language-agnostic template rendering engine | CLI build tool for Van |
| Role | Core: parse `.van` → compile → render HTML + signal JS | Orchestrator: calls Van compilers + manages packages |
| Backend | Any — Java, Go, Python, PHP, etc. via adapter | v0.1 targets Spring Boot (Java) |
| Analogy | Like SQLite (embeddable engine) | Like a CLI that wraps the engine (sqlite3 CLI) |

Van is designed to be **embeddable** — any language can integrate it through a thin adapter:

```
ym build → pre-compiled HTML templates + JS/CSS assets
                        ↓
    Backend adapter reads templates, interpolates {{ expr }} with context data
                        ↓
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ Java adapter│ Go adapter  │ Python      │ PHP adapter │
│ (Spring)    │ (Gin/Echo)  │ (Django)    │ (Laravel)   │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

v0.1 ships with the **Java/Spring Boot adapter** (`van-spring-boot-starter`). Other language adapters are future work.

### 1.2 Pain Points Addressed

| Pain Point | Current State | Van Solution |
|---|---|---|
| DX | Backend templates (Thymeleaf/Twig/Pebble) lack component model, poor IDE support, ugly syntax | Vue-like SFC syntax, component system, scoped styles |
| Frontend/Backend Split | Frontend UI cannot be directly used by backend, requires rewrite | `.van` files as server-side view templates with Vue DX; sharable UI packages |
| Performance & SEO | SPA has poor SEO; SSR (Nuxt/Next) is heavy and requires Node.js | Server-rendered HTML + signal-based JS for interactivity, no Node.js runtime |
| Client interactivity | Thymeleaf/JTE require manual jQuery/vanilla JS | Vue-compatible syntax (`ref`/`computed`/`watch`) compiled to signal-based JS by Van — no virtual DOM |
| Backend lock-in | Each template engine is tied to one language (Thymeleaf→Java, Blade→PHP, ERB→Ruby) | Van engine is language-agnostic — same `.van` templates work across Java, Go, Python, PHP via adapters |

---

## 2. `.van` File Format

Van uses **standard `.van` single-file components**, fully compatible with Vue tooling (Volar, ESLint, Prettier). The key difference from a Vue SPA is that `<template>` is rendered on the server with context data, not in the browser via virtual DOM.

A `.van` file has up to three blocks:

```vue
<!-- user-profile.van -->

<!-- Block 1: Script setup (optional) -->
<script setup lang="ts">
import TabBar from './tab-bar.van'

// Data contract — same defineProps for both backend context and component props
defineProps({
  user: { type: Object, required: true },
  posts: { type: Array, required: true }
})

// Client-side interactivity — runs in the browser
const activeTab = ref('posts')
</script>

<!-- Block 2: Template (required) -->
<template>
  <div class="profile">
    <h1>{{ user.name }}</h1>
    <tab-bar v-model="activeTab" :tabs="['posts', 'likes']" />
    <div v-if="activeTab === 'posts'">
      <article v-for="post in posts" :key="post.id">
        {{ post.title }}
      </article>
    </div>
  </div>
</template>

<!-- Block 3: Scoped styles (optional) -->
<style scoped>
.profile { max-width: 800px; margin: 0 auto; }
</style>
```

### 2.1 Block Summary

| Block | Attribute | Compiled By | Compiled To | Responsibility |
|---|---|---|---|---|
| `<script setup lang="ts">` | `setup`, `lang="ts"` | Van Signal Compiler (Rust) | Signal-based `.js` | `defineProps`, component imports, `.ts`/`.js` imports (services, types, utilities), client-side interactivity (`ref`, `computed`, `watch`) |
| `<template>` | — | Van (Rust) | Server-rendered HTML | View structure, data binding, component resolution |
| `<style scoped>` | `scoped` | Van (Rust) | `.css` file | Scoped styling |

### 2.2 Block Rules

- `<script setup lang="ts">` — optional. Contains `defineProps` (data contract for both backend context and component props), component imports (`.van`), non-component imports (`.ts`/`.js` — services, types, utilities), and client-side interactivity logic (`ref`, `computed`, `watch`, event handlers). Compiled by **Van Signal Compiler** into signal-based JS (no virtual DOM), served alongside the server-rendered HTML.
- `<template>` — required. Uses Vue template syntax. Rendered on the server with data from the controller context.
- `<style scoped>` — optional. Native CSS only. `scoped` attribute generates unique selectors per component.

### 2.3 Data Context

`.van` files do **not** contain server-side business logic. All data is provided externally:

- **Production**: Spring Boot controller passes a `Map` / `Model` to the template
- **Development**: `ym dev` reads mock data from `mock/index.json`

The template accesses context data directly via `{{ }}` interpolation and directive expressions. This is analogous to how Thymeleaf receives its `Model` — the template only consumes data, never fetches it.

```java
// Spring Boot Controller — data preparation lives here
@GetMapping("/users/{id}")
public String userProfile(@PathVariable String id, Model model) {
    User user = userService.findById(id);
    model.addAttribute("user", user);
    model.addAttribute("posts", postService.getByUser(id));
    return "user-profile";  // → renders user-profile.van with this context
}
```

```vue
<!-- user-profile.van — pure view, no business logic -->
<template>
  <h1>{{ user.name }}</h1>
  <article v-for="post in posts" :key="post.id">
    {{ post.title }}
  </article>
</template>
```

### 2.4 `defineProps` — Unified Data Contract

Van uses **standard Vue `defineProps`** for all data declarations — both backend context injection and component-to-component props. There is no custom `defineContext` macro. This design choice ensures:

- **100% Vue compatibility** — no proprietary macros, standard Vue tooling works unchanged
- **Any component is renderable** — the Van engine can directly render any component (not just "pages"), since every component declares its data interface the same way
- **One API to learn** — developers use the same `defineProps` everywhere

```vue
<!-- pages/user-profile.van -->
<script setup lang="ts">
import PostList from '../components/post-list.van'

// Data contract — declares what this component expects
// When rendered by the engine: data comes from controller context
// When used as a child: data comes from parent :prop bindings
defineProps({
  user: {
    type: Object,
    required: true
  },
  posts: {
    type: Array,
    required: true
  },
  isAdmin: {
    type: Boolean,
    default: false
  }
})

// Client-side interactivity
const activeTab = ref('posts')
</script>

<template>
  <h1>{{ user.name }}</h1>
  <post-list :posts="posts" />
</template>
```

`defineProps` enables:

| Capability | Description |
|---|---|
| **IDE autocomplete** | `{{ user.█ }}` → suggests fields based on type declarations |
| **Mock data validation** | `ym dev` warns if `mock/index.json` is missing required fields |
| **Mock data generation** | `ym mock <page>` generates skeleton JSON from `defineProps` |
| **Context class generation** | `ym build` can optionally generate typed backend classes (e.g., Java records; see Section 8.3) |

`defineProps` is **optional**. Without it, templates still render — they just lack IDE support and build-time validation.

### 2.5 IDE Support: `van-language-server`

Van uses the custom `.van` extension. IDE support is provided by **`van-language-server`**, built on the **Volar.js** framework — the same foundation that powers Volar (Vue), Astro, and Svelte language servers.

```
van-language-server (built on Volar.js)
    │
    ├── Reuses from Volar.js:
    │   ├── HTML/CSS language services
    │   ├── TypeScript integration
    │   ├── Vue template directive support (v-if, v-for, etc.)
    │   ├── <script setup> macro handling
    │   └── Embedded language extraction
    │
    └── Van-specific additions:
        ├── .van file type registration
        ├── Van UI package resolution (@van/ui components)
        └── Mock data validation integration
```

| Capability | Source |
|---|---|
| Syntax highlighting | Volar.js (reused) |
| `<template>` directive autocomplete | Volar.js (reused) |
| `defineProps` type inference | Volar.js (reused) |
| `ref` / `computed` / `watch` | Volar.js (reused) |
| Component auto-import | Volar.js + Van package resolution |
| **Van UI package** component discovery | **Van-specific** |

**IDE distribution:**

| IDE | Integration |
|---|---|
| **VS Code** | `van-vscode` extension (bundles `van-language-server`) |
| **IntelliJ / WebStorm** | LSP client connecting to `van-language-server` |
| **Neovim / other editors** | Standard LSP protocol |

**IDE configuration** — TypeScript support for `.van` files:

```json
// tsconfig.json — for type checking in .van files
{ "vueCompilerOptions": { "extensions": [".van"] } }
```

### 2.6 Non-Component Imports (`.ts` / `.js`)

`<script setup>` supports importing from `.ts` and `.js` files — not just `.van` components. This enables reuse of TypeScript services, type definitions, and utility functions.

```vue
<script setup lang="ts">
import type { User, Post } from '../types/models.ts'
import { formatDate, truncate } from '../utils/format.ts'
import { fetchComments } from '../services/comment-service.ts'
import UserCard from '../components/user-card.van'

defineProps<{ user: User, posts: Post[] }>()

const comments = ref([])
async function loadComments(postId: string) {
  comments.value = await fetchComments(postId)
}
</script>
```

#### Import categories and compilation behavior

| Import Kind | Example | Compiled To |
|---|---|---|
| **Type-only import** | `import type { User } from '../types/models.ts'` | Erased — not included in client JS |
| **Value import** | `import { formatDate } from '../utils/format.ts'` | Bundled into the page's signal JS |
| **Component import** | `import UserCard from './user-card.van'` | Resolved by Van compiler (not bundled as JS) |

#### Compilation rules

1. **`import type` → erased**. Type-only imports are stripped at compile time. They exist solely for IDE support and type checking, producing zero runtime output.
2. **Value imports → bundled**. Functions, constants, and classes imported from `.ts`/`.js` files are resolved, transpiled (TS → JS), and bundled into the page's signal JS file. The compiler follows the import graph and tree-shakes unused exports.
3. **Component imports (`.van`) → handled separately**. These are resolved by Van's component compilation pipeline, not bundled as JS modules.

#### Typical project structure

```
src/
├── pages/
│   └── user-profile.van
├── components/
│   └── user-card.van
├── services/               # ← client-side service functions
│   └── comment-service.ts
├── types/                  # ← shared type definitions
│   └── models.ts
└── utils/                  # ← pure utility functions
    └── format.ts
```

#### Design notes

- Imported `.ts`/`.js` code runs **in the browser** (client-side). It is bundled into the signal JS alongside `ref`/`computed`/`watch` code. Do not put server-only logic (DB queries, secrets) in these files.
- The Van compiler does NOT execute or interpret `.ts`/`.js` at compile time — it only resolves, transpiles, and bundles them for the client.
- This is the standard way to share logic across multiple `.van` files without duplicating code in each `<script setup>`.

---

## 3. Template Syntax

The template syntax closely follows Vue 3, targeting near-complete directive coverage.

### 3.1 Interpolation

```html
<!-- Text interpolation -->
<p>{{ user.name }}</p>

<!-- Attribute binding (shorthand) -->
<img :src="user.avatar" :alt="user.name" />

<!-- Full syntax -->
<img v-bind:src="user.avatar" />
```

### 3.2 Directives

| Directive | Description | Example |
|---|---|---|
| `v-if` / `v-else-if` / `v-else` | Conditional rendering | `<span v-if="isAdmin">Admin</span>` |
| `v-for` | List rendering | `<li v-for="item in items" :key="item.id">` |
| `v-bind` (`:`) | Attribute binding | `:href="url"` |
| `v-on` (`@`) | Event binding | `@click="handleClick"` |
| `v-model` | Two-way binding | `<input v-model="query" />` |
| `v-show` | Toggle visibility (CSS) | `<div v-show="visible">` |
| `v-slot` (`#`) | Named slots | `<template #header>` |
| `v-html` | Raw HTML output | `<div v-html="richContent" />` |
| `v-text` | Text content | `<p v-text="message" />` |
| Custom directives | TBD | TBD |

### 3.3 Component Usage

Components use **kebab-case** in templates:

```vue
<script setup lang="ts">
import UserCard from './user-card.van'   // PascalCase import
import TabBar from './tab-bar.van'
</script>

<template>
  <!-- kebab-case usage, auto-mapped from PascalCase import -->
  <user-card :user="user" />
  <tab-bar :tabs="tabs" />
</template>
```

**Naming conventions:**

| Context | Convention | Example |
|---|---|---|
| File name | kebab-case | `user-card.van` |
| Import | PascalCase | `import UserCard from './user-card.van'` |
| Template usage | kebab-case | `<user-card />` |

### 3.4 Slots

Layout and composition via slots, following Vue syntax:

```vue
<!-- layout.van -->
<template>
  <header><slot name="header" /></header>
  <main><slot /></main>
  <footer><slot name="footer" /></footer>
</template>
```

```vue
<!-- page.van -->
<script setup lang="ts">
import Layout from './layout.van'
</script>

<template>
  <layout>
    <template #header>
      <h1>My Site</h1>
    </template>
    <p>Page content here.</p>
    <template #footer>
      <p>Footer</p>
    </template>
  </layout>
</template>
```

### 3.5 Expressions

TBD — Exact expression capabilities (simple/safe subset vs. full JS expressions) to be determined.

---

## 4. Component System

### 4.1 Data Scope Rules (Model A — No Context Penetration)

Van follows **Vue's standard scoping model**: every component only receives data that is explicitly passed to it. The engine's context data (from backend controller or mock JSON) is injected **only into the directly-rendered component** — it does NOT automatically penetrate to child components.

| Scope | Data Source | Access Method |
|---|---|---|
| **Rendered component** | Engine context (controller Map / mock JSON) → injected as props | `{{ user.name }}` via `defineProps` |
| **Slot content** | Parent's scope (the component that provides the slot content) | `{{ title }}` in `<template #name>` |
| **Child component** | Only what parent explicitly passes via `:prop` bindings | `{{ name }}` via `defineProps` |

This means:
- The Van engine renders a component by matching context data keys to its `defineProps` declarations
- Child components only see props explicitly passed by their parent — **no implicit context inheritance**
- Any component can be the "entry point" rendered by the engine, not just page-level files

```vue
<!-- pages/user-profile.van — rendered directly by the engine -->
<script setup lang="ts">
import UserCard from '../components/user-card.van'

// Engine injects controller context into these props
defineProps({
  user: { type: Object, required: true },
  posts: { type: Array, required: true }
})
</script>

<template>
  <h1>{{ user.name }}</h1>              <!-- ✅ reads from props (injected by engine) -->
  <user-card :user="user" />            <!-- explicitly passes data to child -->
</template>
```

```vue
<!-- components/user-card.van — child component, receives only explicit props -->
<script setup lang="ts">
defineProps({
  user: Object
})
</script>

<template>
  <div class="card">
    <h2>{{ user.name }}</h2>            <!-- ✅ reads from props (passed by parent) -->
    <p>{{ posts }}</p>                  <!-- ❌ undefined — parent didn't pass it -->
  </div>
</template>
```

**Why Model A (no penetration)?**
- Matches Vue's existing behavior — no surprises for Vue developers
- Components are truly self-contained and reusable across different contexts
- Data flow is explicit and traceable — easier to debug
- The engine can render *any* component directly (just provide matching props)

### 4.2 `defineProps` — Universal Data Interface

Every `.van` component declares its data interface via `defineProps`, regardless of whether it's rendered directly by the engine or used as a child component:

```vue
<script setup lang="ts">
defineProps({
  user: Object,
  isAdmin: Boolean,
  count: {
    type: Number,
    default: 0
  }
})
</script>
```

**How data arrives depends on context:**

| Scenario | Who provides the data | How |
|---|---|---|
| Engine renders the component directly | Backend controller / mock JSON | Engine matches context keys to `defineProps` |
| Parent component uses it as a child | Parent template | `:prop="expr"` bindings evaluated in parent's scope |

This means the same component can work in both scenarios without any code changes — it just declares what data it needs, and the caller (engine or parent) provides it.

### 4.3 Data Flow

```
Backend Controller (Java / Go / Python / PHP / ...)
    ↓  context data (Map / Dict / HashMap)
    ↓
Van Engine
    ↓  matches context keys → defineProps of the rendered component
    ↓
Rendered .van component (defineProps)
    ↓  :prop="expr" bindings (explicit)
    ↓
Child .van components (defineProps)
    ↓  :prop="expr" bindings (explicit)
    ↓
Sub-components (defineProps)
```

- **Engine → Component**: The engine injects context data into the directly-rendered component by matching context keys to its `defineProps`. This is the **only** point where backend data enters the template tree.
- **Parent → Child**: Parent passes data via `:prop="expr"` bindings. The child receives it through its own `defineProps`. No context data is implicitly available.
- **Slot content**: Evaluated in the **parent's** scope, not the component's. `{{ title }}` inside `<template #header>` reads from the parent that provided the slot content.
- **No implicit inheritance**: A child component never "inherits" the engine context. Every piece of data must be explicitly passed via `:prop` bindings.
- **Priority rule**: If a parent passes `:user="user"` and the engine also has `user` in its context, the **parent's explicit `:prop` binding wins** (standard Vue behavior — props come from the direct parent).

### 4.4 `provide` / `inject` (Future)

For cross-level data sharing (e.g., current user, locale, theme) without prop drilling, a `provide`/`inject` mechanism is planned for a future version:

```vue
<!-- page.van — provide global data -->
<script setup lang="ts">
provide('locale', locale)
provide('currentUser', user)
</script>
```

```vue
<!-- deeply-nested-component.van — inject without prop drilling -->
<script setup lang="ts">
const locale = inject('locale')
const currentUser = inject('currentUser')
</script>
```

This is **not in scope for v0.1**. Props-only is sufficient for most use cases.

---

## 5. Rendering Model

### 5.1 Van Engine (Compile-Time Only)

Van compilation happens **exclusively at build time** — via `ym dev` (in-memory) or `ym build` (to disk). Production backends (Spring Boot etc.) **never compile** `.van` source files; they only consume pre-compiled artifacts.

```
Van Engine (Rust library — compile-time only)
├── van-parser:       source → AST
├── van-compiler:     AST → IR → ServerTemplate
├── van-codegen-html: ServerTemplate + data → HTML string
└── van-signal-gen:   AST → signal-based JS

   ┌── ym dev ──────────┐    ┌── ym build ─────────┐    ┌── Spring Boot ────────┐
   │  in-memory 编译      │    │  编译 → dist/        │    │  读取预编译产物         │
   │  mock data          │    │  pages + components  │    │  {{ expr }} 插值       │
   │  live reload        │    │  + assets (JS/CSS)   │    │  静态资源映射           │
   │  axum dev server    │    │  主题继承在此解决       │    │  不涉及编译            │
   └─────────────────────┘    └──────────────────────┘    └───────────────────────┘
        ↑ Van Engine ↑              ↑ Van Engine ↑              ↑ 不使用 Van Engine ↑
```

| | `ym dev` | `ym build` | Spring Boot |
|---|---|---|---|
| 编译 | in-memory，文件变化时 | 写入 dist/ 目录 | **不编译** |
| 主题继承 | 编译时解决 | 编译时解决 | 已在编译产物中解决 |
| 模块引用 | 编译时解决 | 编译时解决 | 已在编译产物中解决 |
| 数据来源 | `mock/index.json` | 无（模板保留 `{{ expr }}`） | Controller context (Map) |
| Signal JS | 编译后注入页面 | 写入 assets/ | 直接引用静态文件 |

This ensures **zero behavior difference** between dev and prod — `ym dev` and `ym build` use the same Van Engine; Spring Boot only renders the pre-compiled output.

### 5.2 Request Lifecycle

**Dev (`ym dev`):**

```
Browser request GET /user-profile
    ↓
ym dev server (axum):
  1. Read src/pages/user-profile.van
  2. Van Engine (in-memory):
     ├── parse → AST
     ├── compile → ServerTemplate
     ├── compile signals → JS
     └── render(template, mock_data) → HTML
  3. Inject signal JS + scoped CSS + live reload client
    ↓
Return HTML to browser
```

**Prod (Spring Boot — pre-compiled, no WASM):**

```
[Pre-requisite — ym build has already produced compiled artifacts]

Browser request GET /users/1
    ↓
Spring Boot Controller:
    prepares data → model.addAttribute(...)
    return "user-profile"
    ↓
VanViewResolver → VanView:
    1. Find pre-compiled HTML: van.themes/{theme}/pages/user-profile.html
    2. VanRenderer: replace {{ expr }} with Model data → final HTML
    ↓
Return: HTML with <script src="/themes/van1/assets/pages/user-profile.a3f2.js">
    ↓
Browser: renders HTML, requests JS/CSS from assets/ via ResourceHandler
    ↓
Signal JS binds to existing DOM (no hydration)
```

Spring Boot **never** compiles `.van` files — it reads pre-compiled `.html` templates produced by `ym build` (or GitHub Actions). This eliminates the need for a WASM runtime in production.

### 5.3 Partial Refresh

Van supports **partial page updates** — not every interaction requires a full page reload. The server can render and return individual component fragments, and the client swaps them into the existing page.

```
Full page load:    Browser ──GET /users/1──→ Server → complete HTML page
Partial refresh:   Browser ──XHR /users/1/avatar──→ Server → HTML fragment
                   Client JS swaps fragment into the page (no full reload)
```

#### How it works

1. **Server** renders a specific component (or subtree) as an HTML fragment instead of a full page
2. **Client JS** requests the fragment via XHR/fetch and replaces the target DOM element
3. Signal runtime re-binds interactivity on the updated fragment

#### Example

```vue
<!-- components/comment-list.van -->
<script setup lang="ts">
defineProps({ comments: Array })

// Client-side: load more comments without full page reload
async function loadMore() {
  const html = await fetch('/api/comments?page=2&fragment=true').then(r => r.text())
  document.getElementById('comment-list').innerHTML += html
}
</script>

<template>
  <div id="comment-list">
    <div v-for="comment in comments" :key="comment.id">
      {{ comment.body }}
    </div>
  </div>
  <button @click="loadMore">Load more</button>
</template>
```

Partial refresh enables:
- **Infinite scroll** — load content fragments on demand
- **Form submission** — submit and update a section without full reload
- **Live updates** — poll or WebSocket push to refresh specific components
- **Tab switching** — load tab content lazily from server

This is similar to htmx's "HTML over the wire" model, but using Van's signal-based reactivity for client-side coordination instead of HTML attributes.

### 5.4 Key Characteristics

- **Server-rendered HTML** — complete HTML page generated by the backend, like Thymeleaf
- **Signal-based interactivity** — `<script setup>` compiled by Van Signal Compiler into fine-grained signal JS; developer writes Vue-compatible syntax (`ref`, `computed`, `watch`, `@click`), compiler produces direct DOM operations
- **No virtual DOM** — signals update specific DOM nodes directly; no diffing, no patching, no reconciliation
- **HTML-first, JS-enhances** — browser receives a full HTML page; signal JS binds to existing DOM and adds interactivity. No hydration — the signal runtime walks the DOM tree by compiled positional paths to find binding points
- **Minimal JS footprint** — signal runtime ~4KB + per-page signal code ~3-5KB; all component signals inlined in one page JS file, no per-component chunk splitting
- **Partial refresh** — server can render HTML fragments for targeted DOM updates; not limited to full page reloads
- **Not an SPA** — no client-side routing, no hydration, no virtual DOM
- **No Node.js in production** — Van compiles everything at build time; production serves static JS/CSS files alongside server-rendered HTML
- **Clean HTML** — no `data-v-*` attributes; signal bindings use compile-time DOM tree positional targeting (like Vue Vapor / Solid.js)
- **SEO friendly** — full HTML content in initial response
- **Language-agnostic** — Van engine can be adapted to any backend; not tied to a single language
- **Clean separation of concerns** — controllers handle logic, `.van` handles presentation

### 5.5 Client-Side Signal Architecture

Van's client-side enhancement is powered by **fine-grained signals** — inspired by Vue 3 Vapor Mode, Solid.js, and Svelte 5 Runes. No virtual DOM, no hydration, no framework runtime in the traditional sense.

#### Signal Runtime (`@van/runtime`, ~4KB)

```
signal(value)     — reactive value (equivalent to Vue ref())
computed(fn)      — derived value (equivalent to Vue computed())
effect(fn)        — auto-tracking side effect (runs when dependencies change)
watch(source, fn) — explicit watcher (equivalent to Vue watch())
batch(fn)         — batch multiple signal updates into one DOM update
```

Developers write standard Vue syntax. The Van Signal Compiler transforms it:

```
Developer writes          Van compiles to
──────────────            ──────────────
ref(0)            →       signal(0)
computed(...)     →       computed(...)
watch(...)        →       watch(...)
@click="fn"       →       el.addEventListener('click', fn)
v-show="expr"     →       effect(() => el.style.display = ...)
:class="expr"     →       effect(() => el.classList.toggle(...))
v-model="val"     →       addEventListener('input', ...) + effect(...)
{{ expr }}        →       effect(() => el.textContent = ...)
```

#### DOM Targeting: Compile-Time Tree Walking

The compiler knows the exact template structure and generates **positional DOM traversal** — no `data-v-*` attributes needed:

```vue
<template>
  <div class="tabs">
    <button @click="tab = 'a'" :class="{ active: tab === 'a' }">Tab A</button>
    <button @click="tab = 'b'" :class="{ active: tab === 'b' }">Tab B</button>
    <div v-show="tab === 'a'">Content A</div>
    <div v-show="tab === 'b'">Content B</div>
  </div>
</template>
```

Server-rendered HTML (completely clean):
```html
<div class="tabs">
  <button class="active">Tab A</button>
  <button>Tab B</button>
  <div>Content A</div>
  <div style="display:none">Content B</div>
</div>
```

Compiled signal JS:
```js
import { signal, effect } from '@van/runtime'

export function setup(root) {
  const tab = signal('a')

  // Positional targeting — compiler knows the DOM structure
  const tabs = root.firstElementChild
  const btn0 = tabs.children[0]
  const btn1 = tabs.children[1]
  const div0 = tabs.children[2]
  const div1 = tabs.children[3]

  btn0.addEventListener('click', () => tab.value = 'a')
  btn1.addEventListener('click', () => tab.value = 'b')

  effect(() => {
    btn0.classList.toggle('active', tab.value === 'a')
    btn1.classList.toggle('active', tab.value === 'b')
    div0.style.display = tab.value === 'a' ? '' : 'none'
    div1.style.display = tab.value === 'b' ? '' : 'none'
  })
}
```

#### `v-if` Handling (v0.1)

In v0.1, `v-if` with a false initial value is rendered by the server as hidden HTML (`display:none`), and the signal toggles visibility. This simplifies the compiler — `v-if` behaves like `v-show` on the server side, with true conditional DOM creation planned for a future version.

```vue
<!-- Modal: v-if="showModal" with initial value false -->
<div v-if="showModal" class="overlay">
  <div class="modal">...</div>
</div>
```

Server renders:
```html
<!-- Hidden but present in DOM -->
<div class="overlay" style="display:none">
  <div class="modal">...</div>
</div>
```

Signal JS:
```js
effect(() => {
  overlay.style.display = showModal.value ? '' : 'none'
})
```

#### JS Bundle Strategy

All component signals are **inlined into a single page JS file**. No per-component lazy chunks — signal code is too small to benefit from splitting.

```
van-dist/                                     (van.dist directory)
└── van1/
    └── assets/
        ├── js/
        │   ├── van-runtime.js      ~4KB    signal runtime (shared across all pages, cached)
        │   └── pages/
        │       ├── index.a3f2.js   ~5KB    all component signals for this page (inlined + tree-shaken)
        │       ├── user-profile.b1c4.js  ~6KB
        │       └── dashboard.e5d7.js     ~8KB
        └── css/
            └── pages/
                ├── index.a3f2.css          scoped styles
                └── ...
```

Typical page total: **~9KB JS** (runtime + page signals). Heavy third-party libraries (charts, editors) use standard `await import(...)` — this is plain JS, not a Van concern.

---

## 6. Routing

Routing is **fully managed by the backend framework** (e.g., Spring Boot). `.van` files are view templates, not pages with routes.

```java
@GetMapping("/users/{id}")
public String userProfile(@PathVariable String id, Model model) {
    User user = userService.findById(id);
    model.addAttribute("user", user);
    model.addAttribute("posts", postService.getByUser(id));
    return "user-profile";  // → renders user-profile.van
}

@GetMapping("/dashboard")
public String dashboard(Model model) {
    model.addAttribute("stats", statsService.getOverview());
    return "dashboard";  // → renders dashboard.van
}
```

---

## 7. Styling

- **Native CSS only** — no preprocessor (SCSS/LESS) support
- **`scoped` attribute** — generates unique selectors per component to avoid style leaking
- No Tailwind or utility framework built-in

```vue
<style scoped>
/* Compiled to: .profile[data-v-a1b2c3] { ... } */
.profile { max-width: 800px; margin: 0 auto; }
</style>
```

---

## 8. CLI Tool: `ym`

`ym` is the CLI build tool for Van, combining the roles of a package manager (like yarn) and a build tool (like vite). Van is the engine; `ym` is how you use it.

### 8.1 Core Commands

| Command | Description |
|---|---|
| `ym init` | Scaffold a new project |
| `ym dev` | Start development server with hot reload |
| `ym build` | Compile `.van` files → pre-compiled HTML templates + JS/CSS assets for backend deployment |
| `ym generate` | Generate a static HTML site from `.van` files + data |
| `ym add <pkg>` | Install a Van UI package |
| `ym remove <pkg>` | Remove a Van UI package |
| `ym run <script>` | Run a custom script defined in `package.json` |

### 8.2 Dev Server (`ym dev`)

- Independent preview server (no Spring Boot required during development)
- **Same Van Engine as production** — dev server calls the same parser, compiler, and renderer; no separate "dev mode" code path
- Uses **mock data** (`mock/index.json`) to simulate controller context
- Compiles on every file change (**in-memory**, not written to disk)
- Signal JS compiled and injected into served HTML
- **Live reload** — file watcher detects `.van`/mock changes, pushes reload via WebSocket
- When `defineProps` is present, validates mock data against the declared schema and warns on missing/extra fields

### 8.3 Production Build (`ym build`)

`ym build` compiles `.van` source files into pre-compiled artifacts for production deployment. Backend frameworks (Spring Boot etc.) **only consume pre-compiled output** — they never compile `.van` source files.

**Compiled artifacts structure:**

```
dist/{theme}/
├── pages/
│   ├── index.html                  # pre-compiled HTML ({{ expr }} preserved for backend interpolation)
│   ├── user-profile.html
│   └── users/
│       └── detail.html
├── components/
│   ├── user-card.html              # component-level compiled HTML (for direct rendering)
│   ├── nav-bar.html
│   └── comment-list.html
└── assets/
    ├── pages/
    │   ├── index.a3f2c3d4.js       # signal JS
    │   └── index.e5f6g7h8.css      # scoped CSS
    └── components/
        ├── user-card.b2c3d4e5.js
        └── user-card.f1a2b3c4.css
```

**Key points:**

- **Pages**: full HTML documents with `{{ expr }}` placeholders for backend interpolation
- **Components**: also compiled as standalone HTML fragments — Spring Boot can render a component directly (e.g., AJAX partial refresh, fragment rendering)
- **Assets**: hashed JS/CSS files, served as static resources
- **Theme inheritance**: fully resolved at compile time — the output is a flattened, merged result
- **External module imports** (`@scope/pkg`): resolved at compile time — `node_modules/` packages are inlined into the compiled output

> **Status**: Architecture confirmed. Detailed `ym build` implementation design is pending.

---

## 9. Project Configuration: `package.json`

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "scripts": {
    "dev": "ym dev",
    "build": "ym build",
    "generate": "ym generate"
  },
  "dependencies": {
    "@van/ui": "^1.0.0",
    "@van/blog-theme": "^2.0.0"
  },
  "devDependencies": {
    "@van/mock": "^0.1.0"
  }
}
```

### 9.1 UI Package Ecosystem

Van packages are **standard npm packages** containing `.van` files. Published to **npmjs.org** — no custom registry needed. `ym add` / `ym remove` are thin wrappers around npm.

```bash
ym add @van/ui            # → npm install @van/ui
ym add @van/blog-theme    # → npm install @van/blog-theme
ym remove @van/ui         # → npm uninstall @van/ui
ym publish                # → npm publish
```

Installed packages land in `node_modules/` following standard Node conventions:

```
my-project/
├── package.json
├── node_modules/
│   └── @van/ui/
│       ├── package.json
│       ├── components/
│       │   ├── button.van
│       │   ├── card.van
│       │   └── modal.van
│       └── layouts/
│           ├── default.van
│           └── dashboard.van
├── src/
│   └── pages/
│       └── index.van
└── mock/
    └── index.json
```

#### Usage in projects

```vue
<!-- Import from installed package — standard node_modules resolution -->
<script setup lang="ts">
import Button from '@van/ui/components/button.van'
import DashboardLayout from '@van/ui/layouts/dashboard.van'
</script>

<template>
  <dashboard-layout>
    <button variant="primary">Click me</button>
  </dashboard-layout>
</template>
```

#### Package types

| Type | Contains | Use case |
|---|---|---|
| **Component library** | Components (button, card, table, ...) | Reuse UI building blocks across projects |
| **Theme / Starter** | Layouts + components + page templates | Bootstrap a new project with pre-built UI |
| **Page template** | Ready-made page templates | Common pages (login, 404, dashboard, settings) |

#### Theme metadata: `theme.json`

Each theme has a `theme.json` at its root directory, recording theme metadata and inheritance. This is separate from `package.json` (which handles npm publishing) — each file has its own responsibility.

```
@van/blog-theme/
├── package.json          ← npm publishing (name, version, dependencies)
├── theme.json            ← theme config (metadata, inheritance)
├── pages/
├── components/
└── assets/
```

```json
{
  "name": "My Blog Theme",
  "version": "1.0.0",
  "extends": "@van/base-theme"
}
```

| Field | Description |
|---|---|
| `name` | Human-readable theme name |
| `version` | Theme version |
| `extends` | Parent theme — child theme only overrides what it needs (like WordPress child themes) |

**Why `theme.json` instead of `package.json`?**

| | `package.json` | `theme.json` |
|--|---------------|-------------|
| Semantics | npm package description | Theme description |
| Conflict | Project root already has `package.json` | Dedicated, no ambiguity |
| Concern | Publishing, dependencies | Theme metadata, inheritance |

#### Theme inheritance

Themes support **single inheritance** (like WordPress child themes). A child theme only contains files it wants to override — everything else falls through to the parent.

**All themes live in `van.themes` directory** — a unified flat structure. `ym add` downloads npm packages into this directory (not `node_modules/`). Development and production use the same directory layout, so users can browse parent theme source files and override accordingly — even in production environments without npm or ym.

```
/opt/app/van-themes/                      (van.themes)
├── @van/
│   ├── base-theme/                       ← root theme (from npm)
│   │   ├── theme.json                      { "name": "Base" }
│   │   ├── pages/
│   │   │   ├── index.van
│   │   │   ├── 404.van
│   │   │   └── login.van
│   │   ├── components/
│   │   │   ├── header.van
│   │   │   └── footer.van
│   │   └── layouts/
│   │       └── default.van
│   └── blog-theme/                       ← extends base (from npm)
│       ├── theme.json                      { "extends": "@van/base-theme" }
│       ├── pages/
│       │   ├── index.van                   ← overrides base index
│       │   └── post.van                    ← new page
│       └── components/
│           └── header.van                  ← overrides base header
└── my-site/                              ← user theme (local)
    ├── theme.json                          { "extends": "@van/blog-theme" }
    └── components/
        └── header.van                      ← overrides blog-theme header
```

**File resolution**: when looking for a file, walk up the inheritance chain — first match wins:

```
Find pages/index.van:
  1. my-site/pages/index.van           → not found
  2. @van/blog-theme/pages/index.van   → found → use this

Find components/header.van:
  1. my-site/components/header.van     → found → use this

Find pages/404.van:
  1. my-site/pages/404.van             → not found
  2. @van/blog-theme/pages/404.van     → not found
  3. @van/base-theme/pages/404.van     → found → use this
```

**Implementation**: the engine flattens the inheritance chain into an ordered directory list, then all file lookups search this list:

```rust
fn resolve_theme_chain(themes_dir: &Path, theme_name: &str) -> Vec<PathBuf> {
    // Read theme.json → extends → recurse
    // Returns [current, parent, grandparent, ...]
}
```

At compile time, `.van` files from the full chain are merged into a single `files` map (child overrides parent on name collision), then passed to the compiler. No multiple inheritance — avoids diamond problems.

#### Override granularity

Theme inheritance supports two levels of override:

**1. File-level override (default)** — child theme provides a complete replacement file:
```
my-site/pages/index.van       ← entirely replaces parent's pages/index.van
```

**2. Slot-level override** — child theme extends the parent's file and overrides only specific slots, using `<template extends>`:

```vue
<!-- my-site/pages/index.van — only overrides two slots, rest unchanged -->
<template extends>
  <template #header>
    <h1>My Custom Header</h1>
  </template>
  <template #footer>
    <p>My Custom Footer</p>
  </template>
  <!-- all other slots keep parent theme's content -->
</template>
```

The `extends` boolean attribute on `<template>` signals the compiler to:
1. Load the parent theme's same-name file (walk up the inheritance chain)
2. For each `<template #name>` in the child, replace the corresponding slot content in the parent
3. Keep all other slots unchanged
4. Continue with normal resolve pipeline (the merged result is identical to a full page)

This only affects compile time (one extra file load + slot merge). The rendered output is the same as a full file override — zero runtime impact.

If the child `<template>` does NOT have the `extends` attribute, it is a full file-level override (current behavior).

#### Why npm?

| | Custom registry | **npm (chosen)** |
|---|---|---|
| Infrastructure | Build and maintain | Ready-made |
| User accounts | Create from scratch | Developers already have |
| Scoped packages | Implement | `@van/ui` works out of the box |
| Private packages | Build | npm private / Verdaccio |
| CDN | Set up | unpkg / jsDelivr |
| Versioning / semver | Implement | Built-in |
| Lock file | Implement | `package-lock.json` |
| Publish workflow | Implement | `npm publish` |

### 9.2 Static Site Generation

Van can generate **static HTML sites** — no backend server required at runtime. `ym generate` renders all pages with mock data into static HTML + JS + CSS files, ready for deployment to any static host (Netlify, Vercel, GitHub Pages, S3, etc.).

```bash
ym generate
# Output:
#   dist/index.html
#   dist/about/index.html
#   dist/blog/hello-world/index.html
#   dist/assets/style.css
#   dist/assets/app.js
```

#### How it works

1. `ym generate` reads all page `.van` files in `src/pages/`
2. For each page, loads mock data from `mock/index.json` (or a data source config)
3. Van engine renders each page to a complete HTML file
4. Van Signal Compiler compiles `<script setup>` → signal JS bundles
5. Output: static HTML + JS + CSS, deployable anywhere

#### Use cases

| Use case | Example |
|---|---|
| **Personal blog** | Markdown content → Van layout → static HTML |
| **Documentation site** | Structured docs → Van components → searchable static site |
| **Marketing / landing pages** | Design in Van → deploy to CDN |
| **Portfolio** | Van components → static site with client-side interactivity |

#### Comparison with dynamic mode

| | `ym build` (dynamic) | `ym generate` (static) |
|---|---|---|
| Output | Pre-compiled HTML templates (`{{ expr }}` preserved) + JS/CSS assets | Fully rendered HTML files (data already filled in) |
| Runtime | Backend server interpolates `{{ expr }}` with live data | No server (static hosting) |
| Data source | Controller context (live, per-request) | Mock data / content files (build-time) |
| Use case | Web applications | Content sites, blogs, docs |

---

## 10. Rust Architecture

### 10.1 Workspace Structure

```
yummy/
├── Cargo.toml                 # Workspace root
├── crates/
│   ├── ym-cli/                # CLI entry point (ym command)
│   ├── van-parser/            # .van file parser → AST
│   ├── van-compiler/          # AST → IR → code generation (server)
│   ├── van-compiler-wasi/     # WASI binary: stdin JSON → compile_page() → stdout JSON
│   ├── van-codegen-html/      # Server: HTML template generator
│   ├── van-signal-gen/        # Client: signal-based JS generator
│   ├── ym-dev-server/         # Dev server + HMR
│   ├── ym-registry/           # Package management (publish/install)
│   └── ym-core/               # Shared types, package.json parsing, utils
├── packages/
│   ├── van-language-server/   # LSP server (TypeScript, built on Volar.js)
│   └── van-vscode/            # VS Code extension (bundles language server)
```

### 10.2 Compilation Pipeline (Unified Rust)

All pipelines are implemented in Rust as a single library. `ym dev` and `ym build` call the same code — only the I/O differs (in-memory vs disk). **Spring Boot does not call Van Engine** — it only reads pre-compiled output.

```
                            .van file
                               ↓
                         [van-parser]
                               ↓
                           Van AST (shared)
                          /         \
                         /           \
    ┌── Server Pipeline ──┐    ┌── Client Pipeline ──┐
    │                      │    │                      │
    │  [van-compiler]      │    │  [van-signal-gen]    │
    │    ↓                 │    │    ↓                  │
    │  [van-codegen-html]  │    │  Signal-based JS     │
    │    ↓                 │    │  + scoped CSS         │
    │  HTML template       │    │                      │
    │  ({{ expr }} kept)   │    │  (direct DOM ops,    │
    │                      │    │   no virtual DOM)    │
    └──────────────────────┘    └──────────────────────┘
              │                          │
              └────────┬─────────────────┘
                       ↓
    ┌── ym dev ──┐    ┌── ym build ──┐    ┌── Spring Boot ──────┐
    │ in-memory   │    │ write dist/   │    │ reads pre-compiled   │
    │ mock data   │    │ pages/ +      │    │ HTML + assets        │
    │ live reload │    │ components/ + │    │ {{ expr }} → Model   │
    │ axum server │    │ assets/       │    │ no Van Engine needed │
    └─────────────┘    └───────────────┘    └──────────────────────┘
```

Van's Rust crates:
1. **van-parser** — Lexer + hand-written recursive descent parser → Van AST (shared by both pipelines)
2. **van-compiler** — Server: analysis, transformation, optimization → IR
3. **van-codegen-html** — Server: code generation → compiled server template
4. **van-signal-gen** — Client: `<script setup>` + template binding analysis → signal-based JS with compile-time DOM tree targeting

`ym-dev-server` calls `van-parser` + `van-compiler` + `van-codegen-html` + `van-signal-gen` in-memory on each file change. `ym build` calls the same crates and writes output to `dist/`.

### 10.3 Parser

- **Hand-written recursive descent** parser
- Chosen for: best error recovery, highest performance, full control over template syntax (HTML + directives + expressions multi-layer nesting)
- Reference: Vue compiler, Svelte compiler, TypeScript compiler all use this approach

---

## 11. Backend Integration

### 11.1 Van Engine Integration Model

Van is a **language-agnostic** rendering engine. Compilation happens at build time; backends only consume pre-compiled output:

```
[Build time]
.van source → ym build → pre-compiled HTML templates ({{ expr }} preserved) + JS/CSS assets

[Runtime]
Backend Framework
    ↓  context data (Map / Dict / HashMap)
Van Adapter (thin layer per language)
    ↓  reads pre-compiled HTML template
    ↓  replaces {{ expr }} with context data
Response
    ↓  final HTML + linked JS/CSS
Browser
```

Each backend language needs a thin adapter that:
1. Finds the pre-compiled HTML template for the requested view
2. Performs `{{ expr }}` interpolation with controller context data
3. Returns the final HTML string to the framework's response

The adapter does **not** need the Van compiler — it only performs string interpolation on pre-compiled templates.

### 11.2 Integration Options (per language)

Since backends only perform `{{ expr }}` interpolation on pre-compiled HTML, the adapter is extremely lightweight:

| Integration Method | Description | Complexity |
|---|---|---|
| **Native library** | Implement `{{ expr }}` interpolation in the target language | Low (~100 lines) |
| **Shared template library** | Use an existing template engine for `{{ expr }}` interpolation | Lowest |

The Van compiler is **not needed** at runtime. No FFI, WASM, or subprocess is required for production rendering.

### 11.3 Spring Boot (v0.1 Target)

The first adapter targets **Spring Boot / Java**. The starter is a **pure rendering layer** — it reads pre-compiled HTML templates and performs `{{ expr }}` interpolation with Spring Model data. **No compilation happens at runtime.**

#### Architecture

```
[Build time — ym build / GitHub Actions]
.van source files → Van Engine → pre-compiled HTML + JS/CSS assets
                                         ↓
                                  deploy to van.themes/

[Runtime — Spring Boot]
Spring Boot Controller → VanViewResolver → VanView.render()
                                              ↓
                              1. Find pre-compiled .html template
                              2. VanRenderer: replace {{ expr }} with Model data
                              3. Return final HTML
```

**Single-phase rendering (per-request):**
- Read pre-compiled HTML template (with `{{ expr }}` placeholders)
- `VanRenderer` replaces `{{ expr }}` with Spring Model data → final HTML
- ~1-5ms per request, no compilation overhead

The starter does **not** need a WASM runtime, Chicory, or any Van compiler dependency. Theme inheritance, component resolution, and external module imports are all resolved at build time by `ym build`.

#### Pre-compiled Artifacts

`ym build` (or GitHub Actions) produces the following structure, deployed to the `van.themes` directory:

```
van.themes/{theme}/
├── pages/
│   ├── index.html                  # pre-compiled HTML ({{ expr }} preserved)
│   ├── user-profile.html
│   └── users/detail.html
├── components/
│   ├── user-card.html              # standalone component HTML (for direct rendering)
│   └── comment-list.html
└── assets/
    ├── van-runtime.js              # signal runtime (~4KB, shared)
    ├── pages/
    │   ├── index.a3f2c3d4.js       # page signal JS
    │   └── index.e5f6g7h8.css      # page scoped CSS
    └── components/
        └── user-card.b2c3d4e5.js
```

#### Asset Serving

A `ResourceHandler` is auto-configured via `VanAutoConfiguration` — users need zero configuration:

```
GET /themes/van1/assets/pages/index.a3f2c3d4.js
        ↓
van.themes/{theme}/assets/ directory → serve static file
```

#### Template Resolution

```
VanViewResolver: return "index"
        ↓
1. van.themes/{theme}/pages/index.html   ← external, priority
        ↓ not found
2. classpath:templates/{theme}/pages/index.html  ← inside JAR, fallback
        ↓ not found
3. return null (Spring tries next ViewResolver)

VanViewResolver: return "user-card" (component rendering)
        ↓
1. van.themes/{theme}/components/user-card.html
        ↓ not found
2. classpath:templates/{theme}/components/user-card.html
```

Pages and components are both renderable. This enables partial refresh — Spring Boot can render a component directly as an HTML fragment (e.g., for AJAX requests).

#### `van-spring-boot-starter` Components

| Class | Responsibility |
|-------|----------------|
| `VanProperties` | `@ConfigurationProperties(prefix="van")` — themes dir, theme name |
| `VanRenderer` | `{{ expr }}` interpolation: dot-path resolution with Spring Model data → final HTML |
| `VanViewResolver` | Resolve view name → pre-compiled `.html` file → `VanView` |
| `VanView` | Read template + interpolation → write response |
| `VanAutoConfiguration` | `@AutoConfiguration`, register all beans + ResourceHandler for assets |

**Removed from previous design:**
- ~~`VanWasmEngine`~~ — no runtime compilation
- ~~`VanTemplateCache`~~ — no compilation results to cache (HTML files are read from disk, OS-level caching is sufficient)
- ~~`VanThemeResolver` (source collection)~~ — no source files to collect; theme inheritance resolved at build time
- ~~Chicory WASM dependency~~ — not needed

#### Configuration

```yaml
# application.yml
van:
  themes: /opt/app/van-themes     # pre-compiled templates + assets
  theme-name: van1                # active theme name
```

#### Dependency

```gradle
// build.gradle
dependencies {
    implementation project(':van-spring-boot-starter')
    // or from Maven Central:
    // implementation 'xyz.van:van-spring-boot-starter:0.1.0'
}
```

The starter JAR is lightweight — no WASM binary, no compiler dependencies.

### 11.4 Future Adapters

| Language | Framework | Adapter | Status |
|---|---|---|---|
| **Java** | Spring Boot | `van-spring-boot-starter` | v0.1 |
| Go | Gin / Echo / Chi | `van-go` | Future |
| Python | Django / Flask / FastAPI | `van-python` | Future |
| PHP | Laravel / Symfony | `van-php` | Future |
| Rust | Axum / Actix | Native (no adapter needed) | Future |
| .NET | ASP.NET Core | `van-dotnet` | Future |

### 11.5 Build & Deployment

Compilation is a **build-time concern**, not a runtime concern. The deployment pipeline:

```
[Developer / CI]                         [Production]
.van source → ym build → artifacts  →  deploy to van.themes/
                                        Spring Boot reads & renders
```

**Build options:**

| Method | When | Use case |
|--------|------|----------|
| `ym build` (local) | Developer runs locally | Dev/staging deployment |
| GitHub Actions | On push/merge | Automated CI/CD |
| `ym dev` | During development | Local preview (in-memory, not persisted) |

**Deployment:**
- Pre-compiled HTML + assets are placed in the `van.themes/{theme}/` directory
- Can be bundled in the JAR (`src/main/resources/templates/{theme}/`) as fallback
- External `van.themes/` directory takes priority over classpath (hot-fix without redeploy)
- No WASM binary needed in production — the starter JAR is lightweight

**WASM binary** (`van-compiler-wasi.wasm`) is still built for:
- `ym build` internal use (the CLI calls the Van Engine Rust library directly, not WASM)
- Future: other language adapters that embed the compiler (Go, Python, PHP via wasmtime)

```bash
# Build WASM binary (for non-Rust language adapters)
cargo build --target wasm32-wasip1 -p van-compiler-wasi --release
```

---

## 12. Signal System

Signals are the **core of Van's client-side architecture**. Van uses fine-grained reactivity to power all client-side interactivity — no virtual DOM, no diffing, no hydration.

### 12.1 Background

Signals originated from **S.js** (Adam Haile, 2013), popularized by **SolidJS**, and now adopted across the frontend ecosystem (Vue 3.6 Vapor Mode, Svelte 5 Runes, Angular Signals, TC39 proposal). Van adopts this proven model.

### 12.2 Signal Runtime (`@van/runtime`)

The signal runtime is a lightweight (~4KB gzip) library shipped with every Van page:

| API | Vue Equivalent | Description |
|---|---|---|
| `signal(value)` | `ref(value)` | Reactive value, triggers effects on change |
| `computed(fn)` | `computed(fn)` | Derived value, auto-tracks dependencies |
| `effect(fn)` | `watchEffect(fn)` | Side effect, re-runs when dependencies change |
| `watch(source, fn)` | `watch(source, fn)` | Explicit watcher |
| `batch(fn)` | — | Batch multiple updates into one DOM update cycle |

The runtime implements **automatic dependency tracking**: when an `effect` reads a `signal`, it subscribes to that signal. When the signal changes, only its subscribers re-run.

```
signal(0) ──→ effect reads it ──→ subscribes
    │
    └── value changes ──→ only subscribed effects re-run ──→ update specific DOM node
```

### 12.3 No Virtual DOM

Van deliberately omits the virtual DOM layer. Comparison:

```
Vue (traditional):    signal change → re-render component → virtual DOM diff → patch DOM
Vue Vapor:            signal change → compiled DOM update (no VDOM)
Van:                  signal change → compiled DOM update (no VDOM)
                                      ↑ same approach as Vapor / Solid.js
```

Benefits:
- **Less memory** — no virtual DOM tree in memory
- **Less CPU** — no diffing algorithm on every update
- **Smaller runtime** — ~4KB vs ~18KB (Vue) vs ~30KB (React)
- **Predictable performance** — update cost proportional to what changed, not component tree size

### 12.4 Compile-Time DOM Targeting

The Van Signal Compiler generates **positional DOM traversal** code — no runtime `querySelector`, no `data-v-*` attributes. The compiler knows the template structure at build time:

```
Template structure (known at compile time):
<div>              ← root
  <button>         ← root.children[0]
  <button>         ← root.children[1]
  <div>            ← root.children[2]
    <p>            ← root.children[2].children[0]
    <span>         ← root.children[2].children[1]
```

Generated JS:
```js
const btn0  = root.children[0]
const btn1  = root.children[1]
const inner = root.children[2]
const p     = inner.children[0]
const span  = inner.children[1]
```

The HTML stays **completely clean** — no framework artifacts, no data attributes, no IDs injected by the compiler. The DOM output is identical to what a human would hand-write.

### 12.5 Server-Side Applications (Future)

Signals may also play a role in Van's server-side rendering in future versions:

| Application | Description | Status |
|---|---|---|
| Incremental rendering / caching | Only re-render affected template fragments when data changes | Future |
| Dev-time reactive preview | Signals power real-time preview in `ym dev` | Future |
| Compile-time dependency analysis | Signal graph to analyze data bindings, generate optimized render code | Future |

---

## 13. Open Questions (TBD)

| # | Topic | Question |
|---|---|---|
| 1 | ~~Build output format~~ | ~~Resolved: WASM protocol returns `{ html, assets }` — compiler decides asset paths, assets written to `van.dist` as real files~~ |
| 2 | **Expression language** | What expressions are allowed in `{{ }}` and directives? Safe subset vs full JS? |
| 3 | **Signal runtime** | Exact signal runtime API surface, edge cases (nested effects, circular deps, async effects) |
| 4 | ~~Package registry~~ | ~~Resolved: use npmjs.org~~ |
| 5 | ~~Rendering bridge~~ | ~~Resolved: pre-compiled deployment. `ym build` compiles at build time; Spring Boot only reads pre-compiled HTML and performs `{{ expr }}` interpolation. No WASM/Chicory needed at runtime.~~ |
| 6 | **Custom directives** | Support for user-defined directives? |
| 7 | **Multi-language adapters** | Adapter API design for Go, Python, PHP etc. (Van engine is already language-agnostic) |
| 8 | **`defineProps` type system** | Exact type annotation depth for `defineProps` (for context class generation) — simple types only vs nested `fields` declarations |
| 9 | **`van-language-server`** | Volar.js integration depth, IntelliJ LSP support, Van-specific feature scope |
| 10 | **`provide` / `inject`** | Exact API design and implementation timeline for cross-level data sharing |
| 11 | **Static site generation** | Data source format for `ym generate` (JSON, Markdown, YAML?), content directory conventions |
| 12 | ~~UI package format~~ | ~~Resolved: standard npm package.json + node_modules~~ |

---

## 14. Non-Goals (v0.1)

- **No virtual DOM** — signals update DOM directly; no VDOM tree, no diffing, no reconciliation
- **No hydration** — signal JS binds to server-rendered HTML via compile-time positional targeting, not virtual DOM comparison
- **No Vue/Vite runtime dependency** — Van compiles its own signal-based JS; Vue/Vite is not needed at build time or runtime
- No browser-side compilation
- No CSS preprocessor support (SCSS/LESS)
- No client-side routing / SPA mode
- No backend adapters other than Java/Spring Boot (Van engine is language-agnostic, but v0.1 only ships the Java adapter)
- No server-side business logic in `.van` files
- No `provide` / `inject` (props-only for component data passing)

---

## Appendix A: Comparison with Existing Solutions

| Feature | Thymeleaf | JTE | Nuxt/Next SSR | Inertia.js | **Van** |
|---|---|---|---|---|---|
| Language | Java only | Java only | JS/TS | Any (adapter) | **Any** (Van is language-agnostic) |
| Syntax | HTML + `th:*` | Java DSL | Vue/React | Vue/React/Svelte | `.van` SFC (Vue syntax) |
| Components | Fragments | Templates | Full | Full | **Full SFC components** |
| Scoped styles | No | No | Yes | Yes | **Yes** |
| Server rendering | Yes | Yes | Yes | JSON (not HTML) | **Yes** (HTML) |
| No Node.js at runtime | Yes | Yes | No | SSR needs Node | **Yes** (all Rust, no Node.js) |
| Frontend DX | Poor | Medium | Excellent | Excellent | **Excellent** (Volar, DevTools) |
| Client interactivity | Manual jQuery | Manual jQuery | Full SPA | Full SPA | **Signal-based JS** (~4KB runtime, no VDOM) |
| Page navigation | Full reload | Full reload | Client routing | XHR + JSON (no reload) | **Full reload + partial refresh** |
| Data source | Controller Model | Controller Model | API / SSR props | Controller → JSON props | **Controller → Map/Dict** |
| Business logic in template | No | No | Yes | No | **No** |
| Backend lock-in | Java only | Java only | Node.js | Any (adapter) | **None** (Van engine) |

---

## Appendix B: Test Demo Project

`ym init` 脚手架生成的测试项目。示例路径：`~/van-test`

```
van-test/
├── package.json
├── .gitignore
├── mock/
│   └── index.json              # Mock data (keyed by "pages/{name}")
└── src/
    ├── pages/
    │   └── index.van           # Page entry (route: /)
    ├── components/
    │   └── hello.van           # Reusable component
    └── layouts/
        └── default.van         # HTML layout with <slot />
```

开发测试时直接修改此目录下的文件，运行 `ym dev` 即可预览。

---

*End of Spec v0.1*
